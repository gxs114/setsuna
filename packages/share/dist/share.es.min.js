import{isObservable as e}from"@setsuna/observable";function t(e){return"function"==typeof e}function n(e){return"string"==typeof e}function r(e){return"boolean"==typeof e}function o(e){return"[object Object]"===Object.prototype.toString.call(e)}function i(e){return"object"==typeof e}const c=Array.isArray;function f(e){return void 0===e}function s(e){return"number"==typeof e}function a(e){return e instanceof Promise&&t(e.then)&&t(e.catch)}function u(e,t){return Object.is(e.type,t.type)&&Object.is(e.key,t.key)}const l=e=>e.startsWith("on")?e.slice(2).toLocaleLowerCase():e,p=e=>Object.keys(e).reduce(((t,n)=>t+`${n}: ${e[n]};`),""),h=e=>Object.keys(e).reduce(((t,n)=>t+(e[n]?`${n} `:"")),"").trimEnd(),g=e=>e.filter(n).join(" ").trimEnd();function m(e){return Object.keys(e).reduce(((t,n)=>{if("style"===n&&o(e[n]))t[n]=p(e[n]);else if("className"===n||"class"===n){const r=e[n];c(r)?t[n]=g(r):o(r)?t[n]=h(r):t[n]=r}else"key"!==n&&"ref"!==n&&(t[n]=e[n]);return t}),{})}function d(e){return()=>console.error(e)}const y={svg:!0,animate:!0,animateMotion:!0,animateTransform:!0,circle:!0,clipPath:!0,"color-profile":!0,defs:!0,desc:!0,discard:!0,ellipse:!0,feBlend:!0,feColorMatrix:!0,feComponentTransfer:!0,feComposite:!0,feConvolveMatrix:!0,feDiffuseLighting:!0,feDisplacementMap:!0,feDistanceLight:!0,feDropShadow:!0,feFlood:!0,feFuncA:!0,feFuncB:!0,feFuncG:!0,feFuncR:!0,feGaussianBlur:!0,feImage:!0,feMerge:!0,feMergeNode:!0,feMorphology:!0,feOffset:!0,fePointLight:!0,feSpecularLighting:!0,feSpotLight:!0,feTile:!0,feTurbulence:!0,filter:!0,foreignObject:!0,g:!0,hatch:!0,hatchpath:!0,image:!0,line:!0,linearGradient:!0,marker:!0,mask:!0,mesh:!0,meshgradient:!0,meshpatch:!0,meshrow:!0,metadata:!0,mpath:!0,path:!0,pattern:!0,polygon:!0,polyline:!0,radialGradient:!0,rect:!0,set:!0,solidcolor:!0,stop:!0,switch:!0,symbol:!0,text:!0,textPath:!0,title:!0,tspan:!0,unknown:!0,use:!0,view:!0};function b(n){return e(n)?n:(t(n)||o(n))&&e(n.input$)?n.input$:void 0}function j(e,t){const n=[],r=[e];let o=getNextSibling(e);for(;o;){if(r.push(o),8!=o.nodeType){o=getNextSibling(o);continue}if(o.textContent.trim()===`/${t}`){if(0===n.length)return r;n.pop()}o=getNextSibling(o)}}const O=(e,t)=>Object.keys(e).reduce(((n,r)=>(!t.includes(r)&&(n[r]=e[r]),n)),{}),k=e=>e,x=e=>{throw e},v=(e,t,n)=>Object.defineProperty(e,t,{enumerable:!1,configurable:!1,...n});export{v as def,d as identityComponent,c as isArray,r as isBoolean,t as isFunction,s as isNumber,i as isObject,o as isPlainObject,a as isPromise,u as isSomeVNode,n as isString,f as isUndefined,k as noop,x as noopError,g as normalizeArrayClassName,m as normalizeElementProps,h as normalizeObjectClassName,p as normalizeObjectStyle,O as omit,l as resolveEventName,j as resolveNextNodes,b as resolveObservableState,y as svgTags};
